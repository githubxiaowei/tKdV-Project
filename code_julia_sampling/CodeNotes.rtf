{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf610
{\fonttbl\f0\froman\fcharset0 TimesNewRomanPSMT;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww11000\viewh9920\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs28 \cf0 \ul \ulc0 \

\b\fs40 \ulnone To do
\b0\fs28 \
\
- Test speed of ham3direct; breakeven test with ham3fft.\
Also, test the speed for all different values of nmodes, not just powers of 2.\
\
\
- In transfer function, I need to see how many iterations the root solver is taking and think about improving that.\ul \
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \ulnone Original plan: To address Ref1 question about convergence of the transfer function for Lambda large, I plan to run a series of samples with Lambda = 16, 32, and maybe 64. I plan to use 500 and 1000 sweeps to get a visual on the convergence with respect to the number of samples. The value of N does not need to be set in the sampling stage, only later on the transfer function stage. I will primarily use N = Lambda/2, but can also experiment with N = 8 fixed as a straw man.\ul \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \ulc0 \
Little things\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \ulnone - I define the data type RandList with ravar, H2, and H3, but I do not actually use rvar in any of the routines, so maybe I have been silly with my definition.\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \ul \
\

\b\fs40 \ulnone Instructions for running code
\b0\fs28 \ul \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \ulnone \'95 The routine uniform_sample(nmodes, nsweeps) samples from the uniform distribution and produces the output file rand.jld, which contains a list of H2 and H3 values (as well as some parameters). Here nmodes = Lambda is specified but lamfac = N is not specified. The number of samples per sweep is 1e5.\
\
\'95 The routine transfun(\'93rand-16-20\'94, lamfac) computes the transfer function and produces the output file thvars.jld, which contains the upstream and downstream theta values and the skewness upstream and downstream (as well as some parameters).\ul \
\
\ulnone \'95 The routine output_text(\'93thvars-16-8-20.jld\'94) converts the julia file to a text file for DataTank to read.\
\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\b\fs40 \cf0 H3 Computation: recursive or FFT
\b0\fs28 \ul \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \ulnone \
I tested the accuracy of computing H3 using the recursive formula versus the FFT. In short, both methods give highly accurate results. Further notes are as follows.\
\'95 I tested against an exact solution for H3 for the case of nmodes = 1 (actually 2 slightly different exact solutions that are complementary). Both ham3rec and ham3fft give results that are accurate to machine precision. Neither is any more accurate than the other.\
\'95 I then tested ham3rec and ham3fft against one another. The exact solution above is helpful, but only for 2 modes, hence limited. Thus, I simply sampled a vector of complex random values for uhat and compared the results of ham3rec and ham3fft. They gave consistent results to machine accuracy.\
\'95 Interestingly, I do not even need to make the largest mode real for the two methods to give exactly the same result for H3.\
\'95 If I remove the upsampling, ham3rec and ham3fft give very different results, as would be expected. The relative error that is often larger than 1. \
\'95 If I change the upsampling to 3/2, they give somewhat different results, with a relative error that is usually much smaller than 1 but not negligible.\
\'95 Interestingly, if I change the upsampling to 3/2*len + 1, then I get exact results again! \
\'95 Also, if I kill the largest mode and upsample with 3/2*len, I get exact results! That might be an argument for killing the last mode. Nah, an FFT with double the length is just as fast as with 3/2 the length I believe.\
\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\b\fs40 \cf0 FFT Notes
\b0\fs28 \ul \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \ulnone \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \ul Notes\ulnone \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \'95 The FFT routines are only really used in the computation of ham3. In particular, irealfft is used there; realfft is not used in any of the main routines, only in the benchmark tests.\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \ul Downsides of real FFT\ulnone \
The real FFT routines just have too many damn complexities for them to be useful and reliable. To list a few of the curiosities I have found:\
\'95 The relationship between npts and nmodes is not unique. One can have npts = 2*nmodes or 2*nmodes + 1. I believe I have determined that npts = 2*nmodes, with nmodes a power of 2, is the optimal way to use the routines, but of course I still have some uncertainty. I believe npts = 2*nmodes is the proper use by relating it to the regular DFT on a grid (with the number of points a power of 2) and doing a count of the degrees of freedom.\
\'95 Using rfft (physical to spectral) with npts = 2*nmodes, the largest mode must be real for the computation to be correct. Of course, this behavior makes sense after a little analysis. The imaginary part of the largest mode corresponds to sin which aliases to zero on the grid, hence it cannot be seen by the physical signal. Said differently, rfft always outputs the largest mode as real, which makes sense if you do a count of the degrees of freedom.\
\'95 In contrast irfft (spectral to physical) with npts = 2*nmodes works regardless of whether the largest mode is real or not. Maybe the performance suffers if the largest mode is not real though??? Just a guess.\
\'95 The routine irfft destroys the input! WTF?!? Had I not just happened to read that, I would have never figured out a bug I was getting. The routine rfft does not however destroy the input.\
\'95 I still have not even scratched the surface of making FFT plans. Oh man, that might be tedious.\
\
\ul Conclusions\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \ulnone My best choices are:\
1) Only use the recursive computation of H3 and do not worry about any of the real FFT crap.\
2) Zero the largest mode as is done in Matlab DNS so that I am more confident that the real FFT routines are working properly.\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \ul \ulc0 \
Real FFT notes\ulnone \
\'95 To use real FFT between physical uu and spectral uhat, the relationship must be satisfied:\
len(uhat) = div(len(uu), 2) + 1\
Note that in using irfft, the length of uu cannot be inferred from uhat because it can be either 2*len(uhat)-1 or 2*len(uhat)-2. Reference: {\field{\*\fldinst{HYPERLINK "https://juliamath.github.io/AbstractFFTs.jl/stable/api/"}}{\fldrslt https://juliamath.github.io/AbstractFFTs.jl/stable/api/}}\
\
\'95 In my application, we take the irfft of vector [0; uhat] where uhat has length nmodes. We have to do this to include the zero-mode which is set to zero. Thus, the length of uu npoints is either npoints = 2*nmodes or 2*nmodes+1. I belive that npoints = 2*nmodes is the optimal way to use the real FFT routines (see above). Also, in my tests, npoints = 2*nmodes seems to be much faster, by a factor of at least two.\
\
-Side note: At some point, I was worried because the above implies that I am calling irfft with vectors of highly non-composite length. For example, if nmodes=16, then the vector [0; uhat] has length 17 and thus, after upsampling, I am calling irfft with vectors of length (33, 64). The 33 worried me. So I ran some tests where I slightly varied the lengths of the vectors by zeroing the last mode or not and by setting npoints to the two different values allowed. I ran tests calling irfft with vectors of length (32, 63), (32, 62), and (33, 65). The original implementation of (33, 64) was by far the fastest to execute by a factor of more than two. Thus, I believe I was already using the real FFT with vectors of the correct length.\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \'95 I should use FFTW \'91plan\'92, since I am doing transforms of the same size many times. References:\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
{\field{\*\fldinst{HYPERLINK "http://www.fftw.org/fftw2_doc/fftw_2.html"}}{\fldrslt \cf0 http://www.fftw.org/fftw2_doc/fftw_2.html}}\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
{\field{\*\fldinst{HYPERLINK "https://www.reddit.com/r/Julia/comments/5wel0j/fft_speed_vs_matlab/"}}{\fldrslt \cf0 https://www.reddit.com/r/Julia/comments/5wel0j/fft_speed_vs_matlab/}}\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
{\field{\*\fldinst{HYPERLINK "https://www.juliabloggers.com/tag/fftw/"}}{\fldrslt \cf0 https://www.juliabloggers.com/tag/fftw/}}\
{\field{\*\fldinst{HYPERLINK "https://biojulia.net/post/hardware/"}}{\fldrslt https://biojulia.net/post/hardware/}}\
\
\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\b\fs40 \cf0 Timing
\b0\fs28 \ul \ulc0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \ulnone \
Original version of code using FFT (no FFT plan)\
Lambda	nsweeps	sampling	transfer	\
16		100		2.8 mins	3.3 mins\
24		100		*14 mins\
32		100		2.9 mins\
64		100		*16 mins\
\
*Interesting: Lambda = 24 takes much longer than Lambda = 32, which means that the fft routines I am using are very suboptimal. Likely, making a FFTW plan, or else simply computing the transform directly, would be faster for the moderate values of Lambda I am using. Online search suggests the break-even for FFT over direct is about 64.\
*I don\'92t know why Lambda = 64 takes so much longer than 32.\
\
Original version of code using FFT (no FFT plan)\
Lambda	nsweeps	sampling	transfer	\
16		500		14 mins	26 mins\
16		1000		28 mins	54 mins\
32		500		15 mins	26 mins\
32		1000		34 mins	51 mins\
\
Conclusions:\
The cpu time of computing the transfer function is a bit more than the cpu time of sampling (not quite double).\
Question: Why is transfer not faster for 32 compared to 16?\
\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \ul H3 with FFT vs direct\ulnone \
Comparing the sampling with the original FFT with no plan versus direct computation of H3\
Lambda	nsweeps	FFT		direct H3\
16		10		0.27 mins	0.046 mins\
The direct computation of H3 is faster by about a factor of six!!!\
\
\
\
\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\b\fs40 \cf0 Long term\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\b0\fs28 \cf0 \
- In the long run, the better strategy is to sample from a better prior, or to do some basic AR because transfun has to deal with enormously long lists and the vast majority of those are wasted in the mean because their weight is nearly zero.\
\
- Man it would be cool to figure out how to run this sampling algorithm on GPUs. It seems like it would be appropriate since it involves doing the same exact simple arithmetic instructions for multiple data. The only little thing I am worried about is if the GPU is efficient at handling FFT, but I\'92m sure there is a way to do this. Also, I really do need to do some preliminary AR to pare down the data files of stored H2 and H3 values.\
}