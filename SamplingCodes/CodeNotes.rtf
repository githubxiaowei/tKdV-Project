{\rtf1\ansi\ansicpg1252\cocoartf1348\cocoasubrtf170
{\fonttbl\f0\froman\fcharset0 TimesNewRomanPSMT;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww11480\viewh12540\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural

\f0\fs28 \cf0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural
\cf0 \ul \ulc0 To Do\ulnone \
\
- I coded the method to satisfy the statistical matching condition. It seems to work and it is not nearly as expensive as I originally imagined. \
- Next I should input a range of theta- values and plot theta+ to get an idea for the relationship there.\
\
\
- Rerun 3 cases with new format.\
\
\
(Old) Make histograms of H+ under G- and G+ by making uniform bins, sampling, then simply weighting the samples by exp(-theta H) (plus or minus, whichever is appropriate). Normalization should be trivial.\
\
\
\ul Later\ulnone \
\
- Note: Now that I coded microcan separately, I could run several different cases of parameters (invtemp, E0, D0) all effectively simultaneously using the same big ensemble from microcan. Don\'92t do this yet though. There are probably more important things to do with the matching condition.\
\
- Parallelize the for loops that compute H3 and H2.\
\
- Confirm the scaling result for energy of u_x.\
\
\
\
\ul Aug 28, 2018\
\ulnone - I finished the routine gibbs to sample from a Gibbs distribution with 
\i non-zero
\i0  inverse temperature. I tested it with invtemp=0 and it works! It produces histograms of H similar to those produced by gibbs0. I tested it with non-zero invtemp and it works in those cases too. For negative invtemp, it can give skewed distributions as we hoped!\
\
\ul Aug 27, 2018\
\ulnone - I am running large simulations to sample the Gibbs distributions with nsamples up to 2*10^8. For nsamples = 2*10^8, the CPU time is about 5.3 hours and the output data files are about 7.6 GB, which as unmanageably large for DataTank to handle! Therefore, I need to keep nsamples around 10^7 or maybe 2 or 4 times that. \
- I am comparing sampling uhat one at a time (as initially coded) versus all at once (which might be more efficient, lets find out). \
1) Sampling all at once gives a slight 2-5% speedup over one at a time (not much at all)\
2) The bottleneck is definitely computing H3 and H2 rather than sampling uhat.\
3) In one at a time, it makes no difference whether I return uhat and compute H3 and H2 afterwards, or if I compute H3 and H2 inside the function and return them.\
4) In sampling one at a time, using randn, as opposed to rand(dnorm) with dnorm defined in the line above, gives a 5-10% speedup.\
- For these tests, I used nmodes = 10, nsamples = 2e5\
- I wonder if the quality of sampling all at once is better (i.e. less correlations)?\
\
\ul Aug 25, 2018\
\ulnone - I am working towards writing a rejection-based algorithm to sample from a Gibbs measure with non-zero inverse temperature. For this, I would like to calculate the maximum of H3 on the sphere of fixed energy, E=E_0. I made a guess that the max is attained by the Dirichlet kernel and derived a formula for the maximum value of H3.\
- I am testing my guess numerically. The numerics seem to almost always support my guess, with the actually encountered maximum being significantly less than the theoretical maximum (I tested Lambda = 6, 8, 10, 20). Also, I confirmed that H3 of the Dirichlet kernel agrees with my formula (so I did not simply make a mistake). However, for Lambda=4, the max encountered numerically exceeds my theoretical estimate.\
- Also, I tested H2 and it seems to work great.\
\
\ul Aug 24, 2018\ulnone \
- I wrote ham3fft to compute H3 by transforming to physical space. This code is MUCH SHORTER and should be more efficient. In a simple test (H3test) both ham3fft and ham3direct give an accurate solution, with ham3fft slightly more accurate (relative error of 2e-16 compared to 1e-15). So based on this test, there is no need to up-sample (de-alias) the transforms.\
- BUT I put a test in \'91main.jl\'92, which samples uhat randomly from the Gibbs0 distribution. The test compared H3direct vs H3fft and it shows significant differences (relative errors of order 1). When I artifically kill the second half of the spectrum, the two methods agree again. This result suggests I do need upsampling.\
- I implemented upsampling in ifftup and reran the test in main. Now the two methods agree remarkably well. Using 10^4 samples, the maximum relative difference is order 1e-12 and the median difference is order 1e-15. \
\
\ul Aug 23, 2018\ulnone \
- I rewrote the codes to eliminate the k=0 dependence (due to the M=0 assumption). Now, I only store the modes k=1,..,nmodes.\
- I also decided to use the shorthand convention int = 1/(2pi) int_0^\{2pi\}; this makes things SO MUCH EASIER!\
- I wrote the routines realfft and irealfft to convert between physical u and uhat. These routines assume M=0 (the mean of u is zero so the k=0 mode of uhat vanishes). The number of modes is nmodes (k=1,\'85,nmodes) and the number of physical points is npoints = 2*nmodes. These discretized points correspond to [0: dx: 2*pi - dx] where dx = 2*pi/npoints.\
\
\ul Aug 21, 2018\ulnone \
First time around, I coded everything without assuming that etah = 0 necessarily (resulting from the zero momentum assumption). I added this assumption into gibbs0 at the end, but it can be done in a more elegant way later. \
1) In particular, I only need to store etah with indices 1:Lambda (I do not need to store etah_0), which means the length of the vectors will be exactly Lambda instead of Lambda + 1.\
2) Also I suppose the last line of ham3direct can be removed. And also the awkward indexing with k1+1 can be removed.\
\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural

\fs40 \cf0 Misc below\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural

\fs28 \cf0 \ul Idea on sampling uhat for decay (discarded)\ulnone \
Idea: We need to sample uhat to be consistent with decay of the spectrum. Therefore, we can sample each uh_k from a normal distribution N(0, sigma_k) with different variances for each k. Then we could enforce whatever decay we like.\
HOWEVER, this will probably not be an invariant measure, simply because it is not (obviously) a function of the 3 invariants: M, E, H. Thus, I believe we need to control the spectral decay by controlling the expected value of H through the inverse temperature (Gibbs is an invariant measure).}